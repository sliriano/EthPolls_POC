pragma solidity ^0.4.24;

contract Polls {
    
    struct Poll {
        //voting choices
        string description;
        string option1;
        string option2;
        string option3;
        string option4;
        string option5;
        uint optionsUsed; //amount of choices you will have for users to vote on
        address[] voters; // list of people who have voted
        string[] optionList; // list of the options
        mapping(string=>uint) voteValues; //options mapped to amount of votes
        mapping(address=>bool) hasVoted; // keeps track of who has voted
        
    }

    mapping(address=>Poll) public polls; // creator => poll
    
    function createPoll(string description, string option1, string option2, string option3, string option4, string option5) public returns(bool) {
        address[] filler; //filler array passed into the poll
        string[] optionList; //also a filler
        uint num = 0;
        //add options to the optionList
        optionList.push(option1);
        optionList.push(option2);
        optionList.push(option3);
        optionList.push(option4);
        optionList.push(option5);
        for (uint x = 0; x< optionList.length; x++) {
            if (keccak256("") != keccak256(optionList[x])){
              num+=1;
            }
        }
        if (_checkPoll(msg.sender) == true) { // if user has a poll then..
            return false;
        }
        else {
            polls[msg.sender] = Poll(description,option1,option2,option3,option4,option5,num,filler,optionList); // create poll
            return true;
        }
    }
    
    function _checkPoll(address _user) private view returns (bool){
        if(polls[_user].voters.length >0){ //checks if the user currently has a poll
            return true;
        }
        return false;
    }
    
    function vote(address creatorAddress, uint decision) public returns(string) {
        if(_checkVoter(msg.sender,creatorAddress) == false) { // if the user has not yet voted
            if (decision> polls[creatorAddress].optionsUsed || decision <=0){
                return "Invalid Decision";
            }
            else {
                polls[creatorAddress].voteValues[polls[creatorAddress].optionList[decision-1]] += 1; // increase the vote amount by 1
                polls[creatorAddress].hasVoted[msg.sender] = true;
                polls[creatorAddress].voters.push(msg.sender);
                return "Success";
            }
        }
        return "You voted already";
    }

    function _checkVoter(address _user, address creator) private view returns (bool) {
        if (polls[creator].hasVoted[_user]){ // checks if voter has voted yet
            return true;
        }
        return false;
    }
    function destroyPoll(address _user) public {
        if (_user == msg.sender) {
            for (uint x = 0; x < polls[_user].voters.length; x++){
                polls[_user].hasVoted[polls[_user].voters[x]] = false;
            }
           delete polls[_user];
        }
    }
    
    //functions to display the results of each option and the options themselves

    function showOptions(address _user, uint whichOption) public view returns(string) {
        return polls[_user].optionList[whichOption];
    }
    

    function optionOneResults(address _user) public view returns(uint) {
        return polls[_user].voteValues[polls[_user].option1];
    }
    
    function optionTwoResults(address _user) public view returns(uint) {
        return polls[_user].voteValues[polls[_user].option2];
    }

    function optionThreeResults(address _user) public view returns(uint) {
        return polls[_user].voteValues[polls[_user].option3];
    }
    
    function optionFourResults(address _user) public view returns(uint) {
        return polls[_user].voteValues[polls[_user].option4];
    }
    
    function optionFiveResults(address _user) public view returns(uint) {
        return polls[_user].voteValues[polls[_user].option5];
    }
    function displayDescription(address _user) public view returns (string) {
        return polls[_user].description;
    }
}
